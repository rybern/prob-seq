Needed functions:
	intersperse x [a, b, c, ...] = [a, x, b, x, c, x, ...]
	Insertion error: intersperse . geometric . uniform

Branch tagging. Version of each function (?) that tags the state labels with branching information.
Then, once the state sequence is recovered, we retain information about the constructors that generated the observation. This can be used for:
	visualizations
	filtering out classes of generators, such as sequencing error/mutation states.

Probably better to let an AST be the primary representation, and let transition matrices be the 'export format.' ASTS are equally as expressive, but are easier for humans to read and to interpret programmatically.

Idea: encode stegonographic messages into a probabilistic sequence.
	The message would somehow determine the sampling path through the AST.

Idea: try to encode each of Haskell's Data.List functions as a probabilistic sequence. Reuse possible under any cercumstances?

BIO fork:
	read: repeat masker, track in genome browser
	useful examples, templets, builders
	figure out use cases
	Layers for reading errors of particular sequencers,
		mutation types/rates for particular environments




inductive testing:

inductiveSample :: ([(a, Prob)] -> m (a, Prob)) -> ProbSeq (Vector s) s -> m (Vector s, Prob)

data SeqTree s t = AndThen t t
                 | EitherOr Prob t t
                 | Det s
                 deriving Functor

data SampledSeqTree s t = SampledSeqTree {
       samples :: [(s, Prob)]
     , matSeq :: MatSeq s
     , constructor :: SeqTree s t
}

data ProbSeq s = Fix (SeqTree s)
data SampledProbSeq s = Fix (SampledSeqTree s)

unsample :: SampledProbSeq s -> ProbSeq s
unsample = fmap constructor
